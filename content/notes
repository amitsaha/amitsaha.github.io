




// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.mu.Lock()
	defer mux.mu.Unlock()

	if pattern == "" {
		panic("http: invalid pattern " + pattern)
	}
	if handler == nil {
		panic("http: nil handler")
	}
	if mux.m[pattern].explicit {
		panic("http: multiple registrations for " + pattern)
	}

	if mux.m == nil {
		mux.m = make(map[string]muxEntry)
	}
	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}


// Find a handler on a handler map given a path string
// Most-specific (longest) pattern wins
func (mux *ServeMux) match(path string) (h Handler, pattern string) {
	var n = 0
	for k, v := range mux.m {
		if !pathMatch(k, path) {
			continue
		}
		if h == nil || len(k) > n {
			n = len(k)
			h = v.h
			pattern = v.pattern
		}
	}
	return
}






// Serve a new connection.
func (c *conn) serve(ctx context.Context) {
	c.remoteAddr = c.rwc.RemoteAddr().String()
	defer func() {
		if err := recover(); err != nil && err != ErrAbortHandler {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
		}
		if !c.hijacked() {
			c.close()
			c.setState(c.rwc, StateClosed)
		}
	}()


func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
	handler := sh.srv.Handler
	if handler == nil {
		handler = DefaultServeMux
	}
	if req.RequestURI == "*" && req.Method == "OPTIONS" {
		handler = globalOptionsHandler{}
	}
	handler.ServeHTTP(rw, req)
}


ListenAndServe(): nil 

DefaultServeMux is actually another Handler

// A Server defines parameters for running an HTTP server.
// The zero value for Server is a valid configuration.
type Server struct {
	Addr      string      // TCP address to listen on, ":http" if empty
	Handler   Handler     // handler to invoke, http.DefaultServeMux if nil
	TLSConfig *tls.Config // optional TLS config, used by ListenAndServeTLS


ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:


Example code:

package main

import "net/http"
import "fmt"

type mytype struct{}

func (t *mytype) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello there from Handlefunc")
}

func main() {

	t := new(mytype)
	http.Handle("/", t)
	http.ListenAndServe(":8080", t)
}


Anything that has a ServeHTTP() method can be used as a handler.

// HTTP server with middleware
package main

import (
	"fmt"
	"net/http"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	// Send a response
	fmt.Fprintf(w, "Hi there! %s", r.URL.Path[1:])
	// Send another response
	fmt.Fprintf(w, "Hi again!")
}

// This handles /ping requests, but is wrapped by the "makeHandler"
// function below
func pingHandler(w http.ResponseWriter, r *http.Request, s string) {
	fmt.Fprintf(w, "Pong! %s", s)
}

// This is a function which returns a http.HandlerFunc, useful to implement common logic
// across Handlers
// It accepts a function as argument which takes in http.ResponseWriter, *http.Request
// and a string
func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fn(w, r, "testing")
	}
}

func main() {
	http.HandleFunc("/", rootHandler)
	http.HandleFunc("/ping", makeHandler(pingHandler))
	// nil argument here specifies using the DefaultServeMux
	http.ListenAndServe(":8080", makeHandler(pingHandler))
}








http://jordanorelli.com/post/42369331748/function-types-in-go-golang
https://golang.org/doc/effective_go.html#interface_methods