<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Programming and Writing about it</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2016-01-20T11:00:00+10:00</updated><entry><title>tempfile.NamedTemporaryFile() in Python</title><link href="/tempfilenamedtemporaryfile-in-python.html" rel="alternate"></link><published>2016-01-20T11:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2016-01-20:tempfilenamedtemporaryfile-in-python.html</id><summary type="html">&lt;p&gt;In Python, when you need to create a temporary file with a filename
associated to it on disk, &lt;a class="reference external" href="https://docs.python.org/2/library/tempfile.html#tempfile.TemporaryFile"&gt;NamedTemporaryFile&lt;/a&gt;
function in the &lt;tt class="docutils literal"&gt;tempfile&lt;/tt&gt; is the goto function. Here are some use
cases that I think one might use it for and&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Case #1: You simply need a named empty temporary file&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You just want a file object (pointing to an &lt;em&gt;empty&lt;/em&gt; file) which has a
filename associated to it and hence you cannot use a &lt;a class="reference external" href="https://docs.python.org/2/library/stringio.html"&gt;StringIO&lt;/a&gt; objects:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
from tempfile import NamedTemporaryFile
f = NamedTemporaryFile()

# use f
..
&lt;/pre&gt;
&lt;p&gt;Once &lt;tt class="docutils literal"&gt;f&lt;/tt&gt; is garbage collected, or closed explicitly, the file will automatically be
removed from disk.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Case #2: You need a empty temporary file with a custom name&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You need a temporary file, but want to change the filename to
something you need:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
from tempfile import NamedTemporaryFile
f = NamedTemporaryFile()

# Change the file name to something
f.name = 'myfilename.myextension'

# use f
&lt;/pre&gt;
&lt;p&gt;Since you change the name of the file, this file will automatically
&lt;em&gt;not&lt;/em&gt; be removed from disk when you close the file or the file object is
garbage collected. Hence, you will need to do so yourself:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
from tempfile import NamedTemporaryFile
f = NamedTemporaryFile()

# Save original name (the &amp;quot;name&amp;quot; actually is the absolute path)
original_path = f.name

# Change the file name to something
f.name = 'myfilename.myextension'

# use f

..

# Remove the file
os.unlink(original_path)
assert not os.path.exists(original_path)
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Case #3: You need a temporary file, write some contents, read from it later&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This use case is where you need a temporary file, but you want to work
with it like a &amp;quot;normal&amp;quot; file on disk - write something to it and
later, read it from it. In other words, you just want to control when
the file gets removed from disk.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
from tempfile import NamedTemporaryFile
# When delete=False is specified, this file will not be
# removed from disk automatically upon close/garbage collection
f = NamedTemporaryFile(delete=False)

# Save the file path
path = f.name

# Write something to it
f.write('Some random data')

# You can now close the file and later
# open and read it again
f.close()
data = open(path).read()

# do some work with the data

# Or, make a seek(0) call on the file object and read from it
# The file mode is by default &amp;quot;w+&amp;quot; which means, you can read from
# and write to it.
f.seek(0)
data = f.read()

# Close the file
f.close()

..

# Remove the file
os.unlink(path)
assert not os.path.exists(path)
&lt;/pre&gt;
&lt;p&gt;By default &lt;tt class="docutils literal"&gt;delete&lt;/tt&gt; is set to &lt;tt class="docutils literal"&gt;True&lt;/tt&gt; when calling
&lt;tt class="docutils literal"&gt;NamedTemporaryFile()&lt;/tt&gt;, and thus setting it to &lt;tt class="docutils literal"&gt;False&lt;/tt&gt; gives more
control on when the file gets removed from disk.&lt;/p&gt;
</summary></entry><entry><title>Mock objects and non-existent attributes/methods in Python</title><link href="/mock-objects-and-non-existent-attributesmethods-in-python.html" rel="alternate"></link><published>2016-01-11T14:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2016-01-11:mock-objects-and-non-existent-attributesmethods-in-python.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Updated&lt;/em&gt;: Fixed typo in the last paragraph.&lt;/p&gt;
&lt;p&gt;Today, I was curious to see this behavior of &lt;tt class="docutils literal"&gt;Mock()&lt;/tt&gt; objects when using &lt;a class="reference external" href="https://github.com/testing-cabal/mock"&gt;mock&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from mock import Mock
&amp;gt;&amp;gt;&amp;gt; m = Mock()
&amp;gt;&amp;gt;&amp;gt; m.i_dont_exist
&amp;lt;Mock name='mock.i_dont_exist' id='139841609578768'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; m.i_dont_exist()
&amp;lt;Mock name='mock.i_dont_exist()' id='139841609106896'&amp;gt;
&lt;/pre&gt;
&lt;p&gt;The above is expected, since I have not declared a spec when creating the &lt;tt class="docutils literal"&gt;Mock()&lt;/tt&gt; object, so even when you call a non-existent method or get/set a non-existent attribute, you will not get a &lt;tt class="docutils literal"&gt;AttributeError&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;However, I was suprised by the following:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; m.assert_not_calledd
Traceback (most recent call last):
 File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
File &amp;quot;/home/asaha/.local/share/virtualenvs/606fc8723c1a01b/lib/python2.7/site-packages/mock/mock.py&amp;quot;, line 721, in _    _getattr__
   raise AttributeError(name)
 AttributeError: assert_not_calledd
&lt;/pre&gt;
&lt;p&gt;And the following as well:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; m.assert_foo
Traceback (most recent call last):
File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
File &amp;quot;/home/asaha/.local/share/virtualenvs/606fc8723c1a01b/lib/python2.7/site-packages/mock/mock.py&amp;quot;, line 721, in __getattr__
  raise AttributeError(name)
  AttributeError: assert_foo
&lt;/pre&gt;
&lt;p&gt;I guessed that there is likely a check explicitly for &lt;strong&gt;non-existent
attributes&lt;/strong&gt; starting with &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt;, and if it finds so, it will
raise a &lt;tt class="docutils literal"&gt;AttributeError&lt;/tt&gt;.  If you look at the &lt;a class="reference external" href="https://github.com/testing-cabal/mock/blob/master/mock/mock.py#L708"&gt;__getattr__&lt;/a&gt;
method in &lt;tt class="docutils literal"&gt;mock.py&lt;/tt&gt;, you will see that this is pretty much what is
happening. The exact lines are below:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
if not self._mock_unsafe: # self._mock_unsafe is by default False
    if name.startswith(('assert', 'assret')): # It comes here and an AttributeError is raised
        raise AttributeError(name)
&lt;/pre&gt;
&lt;p&gt;This is certainly a good thing, since I have often seen
&lt;a class="reference external" href="http://engineeringblog.yelp.com/2015/02/assert_called_once-threat-or-menace.html"&gt;assert_called_once&lt;/a&gt;
in codebases, and is fairly easy to overlook.&lt;/p&gt;
</summary></entry><entry><title>Data only Docker containers</title><link href="/data-only-docker-containers.html" rel="alternate"></link><published>2015-12-13T11:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-12-13:data-only-docker-containers.html</id><summary type="html">&lt;p&gt;In this post, we shall take a look at the idea of data only
containers - containers whose sole purpose is to exist on the &lt;em&gt;docker
host&lt;/em&gt; so that other containers can have portable access to a
persistent data volume.&lt;/p&gt;
&lt;div class="section" id="why-do-we-need-a-persistent-data-volume"&gt;
&lt;h2&gt;Why do we need a persistent data volume?&lt;/h2&gt;
&lt;p&gt;We will experiment with the &lt;tt class="docutils literal"&gt;jenkins&lt;/tt&gt; image from the &lt;a class="reference external" href="https://hub.docker.com/_/jenkins/"&gt;docker
hub&lt;/a&gt;. Let's run a jenkins
container using &lt;cite&gt;$ sudo docker run -p 8080:8080 jenkins&lt;/cite&gt;. Now, if we
visit the URL &lt;cite&gt;http://docker-host-ip:8080&lt;/cite&gt;, we will see the familiar
Jenkins home page.&lt;/p&gt;
&lt;p&gt;By default, a Jenkins installation doesn't come with any
authentication configured. Hence, we will first setup a simple
authentication setup using Jenkins' own user password database. To do
so, we will visit the URL:
&lt;cite&gt;http://docker-host-ip:8080/configureSecurity/&lt;/cite&gt; and check the &lt;tt class="docutils literal"&gt;Enable
security&lt;/tt&gt; checkbox and then select the &lt;tt class="docutils literal"&gt;Jenkins&lt;/tt&gt; own user database`
option, and check the &lt;tt class="docutils literal"&gt;Allow users to sign up&lt;/tt&gt; check box under
&lt;tt class="docutils literal"&gt;Security Realm&lt;/tt&gt;, select the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Logged-in&lt;/span&gt; users can do anything&lt;/tt&gt;
option and finally click on &lt;tt class="docutils literal"&gt;Save&lt;/tt&gt;. This will bring us to the login
page from where we can create a new account since we don't have one
yet. Now, we will exit out of the container - we can use &lt;tt class="docutils literal"&gt;Ctrl + c&lt;/tt&gt;
combination for that. Now, if we restart the container using the
previous command, you will see that none of the configuration changes
above has been saved.&lt;/p&gt;
&lt;p&gt;The reason for that is because none of the changes we make during a
container's lifetime in it's own file system is preserved. So, we need
&lt;em&gt;data volumes&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="persistent-data-with-a-volume-mount"&gt;
&lt;h2&gt;Persistent data with a volume mount&lt;/h2&gt;
&lt;p&gt;If you look at the
&lt;a class="reference external" href="https://github.com/jenkinsci/docker/blob/master/Dockerfile"&gt;Dockerfile&lt;/a&gt;
you will see the command &lt;tt class="docutils literal"&gt;VOLUME /var/jenkins_home&lt;/tt&gt;. This
essentially means that the mount point &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt; points to
a location on the docker host. Hence, the changes made in that
directory will be available from the host even after you have exited
the container. However, the catch here is that every time you run a
new container, the host location it mounts to will change and hence as
we saw above, the data we wrote (via the configuration changes) were
not visible the next time we started a container from the same
image. To achieve that, we have to do things slightly differently. We
will start the container and give a name to it:&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;`
$ sudo docker run &lt;span class="pre"&gt;-p&lt;/span&gt; 8080:8080 &lt;span class="pre"&gt;--name&lt;/span&gt; jenkins jenkins
`&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;We will perform the same configuration changes above and exit the
container using Ctrl + C. Next, we will &lt;tt class="docutils literal"&gt;start&lt;/tt&gt; the container using
&lt;tt class="docutils literal"&gt;sudo docker start jenkins&lt;/tt&gt;. You will see all your changes have been
preserved.&lt;/p&gt;
&lt;p&gt;So, now we have a setup of jenkins where our changes are preserved, so
long as we make sure we start/stop the containers and not run a new
container from the &lt;tt class="docutils literal"&gt;jenkins&lt;/tt&gt; image. The key point to take away from
here is that for a specific container, the host directory the volume
maps to is always the same. This leads to the use of what is commonly
referred to as &lt;tt class="docutils literal"&gt;data containers&lt;/tt&gt; for persistent data storage in
containers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-data-containers-for-persistent-storage"&gt;
&lt;h2&gt;Using data containers for persistent storage&lt;/h2&gt;
&lt;p&gt;The idea here is that you use the same base image from which your
actual container will run to only create a container (using &lt;tt class="docutils literal"&gt;docker
create&lt;/tt&gt;), not run it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ sudo docker create --name jenkins-data jenkins
&lt;/pre&gt;
&lt;p&gt;We gave the name &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jenkins-data&lt;/span&gt;&lt;/tt&gt; to this container and it's only
purpose is to be there on our filesystem to serve as a source of
persistent &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt; for other jenkins containers. Let's
run a jenkins container now:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ sudo docker run --volumes-from jenkins-data -p 8080:8080 jenkins
&lt;/pre&gt;
&lt;p&gt;As earlier, we can now go to the Jenkins home page at
&lt;cite&gt;http://docker-host-ip:8080/configureSecurity/&lt;/cite&gt; and make the above
configuration changes. You can now exit the container and use the
above command to run another jenkins container. The changes will still
be visible. We are no more restricted to starting and stopping the
same container since our &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jenkins-data&lt;/span&gt;&lt;/tt&gt; container will have all our
changes stored in its &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt;. You can have other
containers (perhaps a container for
&lt;a class="reference external" href="https://github.com/discordianfish/docker-lloyd"&gt;backing up&lt;/a&gt; your
&lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt;) being able to access the same data by using the
same &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;volumes-from&lt;/span&gt;&lt;/tt&gt; option.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="comparison-to-volume-mounting-a-host-directory"&gt;
&lt;h2&gt;Comparison to volume mounting a host directory&lt;/h2&gt;
&lt;p&gt;The alternative to using data containers is to mount a directory from
the host as &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt; in the container. This approach will
solve our end-goal, but there are two additional steps that one would
need to do:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Decide which host location to use, perhaps creating it&lt;/li&gt;
&lt;li&gt;Making sure the container will have appropriate read-write permissions (including &lt;a class="reference external" href="www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/"&gt;SELinux
labels&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We don't need to do either of these when using data containers. As
long as the image we plan to use has the appropriate &lt;tt class="docutils literal"&gt;VOLUME&lt;/tt&gt;
command in it's Dockerfile, we can adopt the same approach we did
here to make sure the data we care about is persisted. For images,
which don't, we can easily enough create our own image and add the
appropriate &lt;tt class="docutils literal"&gt;VOLUME&lt;/tt&gt; commands. And hence, this is a &lt;strong&gt;portable&lt;/strong&gt;
approach to data persistence - it is not reliant on the host
setup.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, these are the main reasons why data containers are a
good approach to have persistent storage for your containers:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;No requirement to setup host&lt;/li&gt;
&lt;li&gt;The permissions are automatically taken care of since we are using the same base image&lt;/li&gt;
&lt;li&gt;Multiple containers can easily have access to the same data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following links may be helpful to learn more:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.docker.com/userguide/dockervolumes/"&gt;Managing data in Containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://medium.com/&amp;#64;ramangupta/why-docker-data-containers-are-good-589b3c6c749e"&gt;Why Docker Data Containers are Good&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary></entry><entry><title>A virtualenv first approach to Python projects</title><link href="/a-virtualenv-first-approach-to-python-projects.html" rel="alternate"></link><published>2015-11-30T12:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-11-30:a-virtualenv-first-approach-to-python-projects.html</id><summary type="html">&lt;p&gt;I have until the last few months (of my ~4 years of working with
Python) always worked without virtualenv for all my Python
projects. Why? I think I found the whole idea of having to do the
following two steps before I work on something cumbersome:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Remember the exact virtualenv name, and then&lt;/li&gt;
&lt;li&gt;Activate it&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That said, I was very much aware that it was certainly a good thing
to do and would cause me less headaches someday. That someday finally
came, and I ran into conflicting package requirements for applications
which needed to run simultaneously. This forced me to start using
virtualenvs. I think I also found the tool which will make me  keep
using them even when I don't &lt;em&gt;need&lt;/em&gt; to. The tool is &lt;a class="reference external" href="https://github.com/berdario/pew"&gt;pew&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="installation-and-basics"&gt;
&lt;h2&gt;Installation and Basics&lt;/h2&gt;
&lt;p&gt;The home page lists various options of installing &lt;tt class="docutils literal"&gt;pew&lt;/tt&gt;. The most
straightforward is of course to just use &lt;tt class="docutils literal"&gt;pip install pew&lt;/tt&gt;. Once you
have it installed, typing &lt;tt class="docutils literal"&gt;pew&lt;/tt&gt; lists the various sub-commands, such
as &lt;tt class="docutils literal"&gt;new&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;workon&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;ls&lt;/tt&gt; and others. Eac of the sub-commands is
accompanied by a summary of they will do.&lt;/p&gt;
&lt;p&gt;So far, I have been mostly working with the above sub-commands. Here
is how we can create a new virtualenv:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ pew new flask-graphql-demo
New python executable in flask-graphql-demo/bin/python2
Also creating executable in flask-graphql-demo/bin/python
Installing setuptools, pip...done.
Launching subshell in virtual environment. Type 'exit' or 'Ctrl+D' to return.
flask-graphql-demo $
&lt;/pre&gt;
&lt;p&gt;Our virtualenv &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;flask-graphql-demo&lt;/span&gt;&lt;/tt&gt; is created and we are in it, which we can check:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ which pip
~/.local/share/virtualenvs/flask-graphql-demo/bin/pip
&lt;/pre&gt;
&lt;p&gt;We can do all our usual work now (installing other packages, running
our applications) and once done, we can simply &lt;tt class="docutils literal"&gt;exit&lt;/tt&gt; and we will be
out of the virtualenv.&lt;/p&gt;
&lt;p&gt;Now, if I want to resume work on this particular project, I can first
use &lt;tt class="docutils literal"&gt;pew ls&lt;/tt&gt; to list the currently created virtualenvs:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ pew ls
flask-graphql-demo
&lt;/pre&gt;
&lt;p&gt;and then use &lt;tt class="docutils literal"&gt;pew workon &lt;span class="pre"&gt;flask-graphql-demo&lt;/span&gt;&lt;/tt&gt; to start working on it
again. On Linux, &lt;tt class="docutils literal"&gt;pew workon&lt;/tt&gt; also gives me all the available
virtualenvs as suggestions automatically.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;As you may have already seen, &lt;tt class="docutils literal"&gt;pew&lt;/tt&gt; has a number of other features
which should make working with &lt;tt class="docutils literal"&gt;virtualenvs&lt;/tt&gt; really easy. It has
definitely made me change my approach to working on Python projects.&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><title>PYTHONHASHSEED and your tests</title><link href="/pythonhashseed-and-your-tests.html" rel="alternate"></link><published>2015-11-19T11:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-11-19:pythonhashseed-and-your-tests.html</id><summary type="html">&lt;p&gt;Recently at work, I wanted to test a string which was being created by the &lt;tt class="docutils literal"&gt;urllib.urlencode()&lt;/tt&gt; function. My first attempt was simple - test my expected string with that being created by the function above using unittest's &lt;tt class="docutils literal"&gt;assertEquals()&lt;/tt&gt; function. It passed all the times I ran the tests before I committed the code, but it started failing when the tests were ran as part of the deployment process.&lt;/p&gt;
&lt;p&gt;The input to the &lt;tt class="docutils literal"&gt;urllib.urlencode()&lt;/tt&gt; function is a dictionary of key value pairs and hence the returned value can really be any of the arrangements of the key value pairs. So, for example &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;{'key1':'value',&lt;/span&gt; &lt;span class="pre"&gt;'key2':'value'}&lt;/span&gt;&lt;/tt&gt; can result in the query string &lt;tt class="docutils literal"&gt;key1=value&amp;amp;key2=value&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;key2=value&amp;amp;key1=value&lt;/tt&gt;. We cannot know for sure and we shouldn't need to.&lt;/p&gt;
&lt;p&gt;Thus, we cannot use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;self.assertEquals(urllib.urlencode({'key1':'value',&lt;/span&gt; &lt;span class="pre"&gt;{'key2':'value'}),&lt;/span&gt; 'key1=value&amp;amp;key2=value')&lt;/tt&gt; without the possibility that it will fail eventually. The reason why we see such behaviour of course is that for dictionaries, the order in which the keys are stored is not deterministic - or known apriori. You can see this behaviour by explicitly setting the value of &lt;a class="reference external" href="https://docs.python.org/3.3/using/cmdline.html#envvar-PYTHONHASHSEED"&gt;PYTHONHASHSEED&lt;/a&gt; to different values.&lt;/p&gt;
&lt;p&gt;So, how should we write such tests? Let's see one possible way which I will state as - &lt;strong&gt;Instead of asserting the equality of entire objects, we should be testing for the presence of the expected constituent objects&lt;/strong&gt;. I demonstrate it via two similar examples:&lt;/p&gt;
&lt;p&gt;(Note that I have used the builtin &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; statement to test here)&lt;/p&gt;
&lt;div class="section" id="url-encoding-via-urllib-urlencode"&gt;
&lt;h2&gt;URL encoding via urllib.urlencode()&lt;/h2&gt;
&lt;p&gt;As our first example, let's consider the &lt;tt class="docutils literal"&gt;urllib.urlencode()&lt;/tt&gt; function:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
 # Test for the role of PYTHONHASHSEED - urllib urlencode

import urllib
urlencode_input = {'param1': 'value', 'param2': 'value'}
expected_query_string = 'param1=value&amp;amp;param2=value'

# This will fail for *some* PYTHONHASHSEED
def test_urlencode_1():
    assert urllib.urlencode(urlencode_input) == expected_query_string

# This will not fail for *any* PYTHONHASHSEED
def test_urlencode_2():
    query_string = urllib.urlencode(urlencode_input)
    assert 'param1=value' in query_string
    assert 'param2=value' in query_string
&lt;/pre&gt;
&lt;p&gt;Run the above tests a few times each starting with a different value of &lt;tt class="docutils literal"&gt;PYTHONHASHEED&lt;/tt&gt; (for. e.g on Linux/Mac OS X, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONHASHSEED=&amp;lt;some&lt;/span&gt; integer&amp;gt; nosetests&lt;/tt&gt;) and you will be easily able to see that the first test will fail for some value, but the second test will always pass.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="joining-strings-from-dictionaries"&gt;
&lt;h2&gt;Joining strings from dictionaries&lt;/h2&gt;
&lt;p&gt;This is similar to the previous example. Assume a function below which basically concatenates multiple key value pairs to create the conditional part of a SQL &lt;tt class="docutils literal"&gt;WHERE&lt;/tt&gt; clause:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
def create_where_clause(conditions):
    where_clause = ''
    for k, v in conditions.iteritems():
        where_clause += '%s=%s AND ' % (k, v)
    # remove the last AND and a trailing space
    return where_clause[:-5]
&lt;/pre&gt;
&lt;p&gt;Here are two ways of testing this function - the first will fail for some test run, where as the second will not:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# This will fail for *some* PYTHONHASHSEED
def test_where_clause_1():

    where_clause = create_where_clause({'item1': 1, 'item2': 2})
    expected_where_clause = 'item1=1 AND item2=2'
    assert where_clause==expected_where_clause

# This will not fail for *any* PYTHONHASHSEED
def test_where_clause_2():

    where_clause = create_where_clause({'item1': 1, 'item2': 2})

    # Deconstruct the string returned into individual conditions
    conditions = [cond.strip() for cond in where_clause.split('AND')]
    assert 'item1=1' in conditions
    assert 'item2=2' in conditions
&lt;/pre&gt;
&lt;p&gt;If you run the above tests with different &lt;tt class="docutils literal"&gt;PYTHONHASHSEED&lt;/tt&gt; values, you will notice similar behaviour to the previous example.&lt;/p&gt;
&lt;p&gt;If you are using &lt;a class="reference external" href="https://testrun.org/tox/latest/example/basic.html#special-handling-of-pythonhashseed"&gt;tox&lt;/a&gt; to run your tests, it automatically sets &lt;tt class="docutils literal"&gt;PYTHONHASHSEED&lt;/tt&gt; to a random integer when it is invoked. Hence, if you have never had your tests fail so far, there is a good chance your tests do not make any assumptions of order when dealing with Python dictionaries - but that of course is no guarantee that your tests are completely free since there may be this particular random number that has not been tried yet! So, ideally you may just want to do run your tests (especially if they don't take long) for a large number of PYTHONHASHSEED values just to be more confident.&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><title>Mounting a docker volume on SELinux enabled host</title><link href="/mounting-a-docker-volume-on-selinux-enabled-host.html" rel="alternate"></link><published>2015-10-05T11:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-10-05:mounting-a-docker-volume-on-selinux-enabled-host.html</id><summary type="html">&lt;p&gt;My workflow with docker usually involves volume mounting a host
directory so that I can read and write to the host directory from my
container as a &lt;em&gt;non-root&lt;/em&gt; user. On a Fedora 23 host with SELinux
enabled, this is what I have to do differently:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Use: -v /var/dir1:var/dir1:Z
&lt;/pre&gt;
&lt;p&gt;Note the extra Z above? You can learn more about it this
&lt;a class="reference external" href="http://www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/"&gt;Project Atomic blog post&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>Standalone open source puppet setup on Fedora</title><link href="/standalone-open-source-puppet-setup-on-fedora.html" rel="alternate"></link><published>2015-10-01T14:54:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-10-01:standalone-open-source-puppet-setup-on-fedora.html</id><summary type="html">&lt;p&gt;My goal in this post is to show how to setup puppet in standalone mode on a Fedora 23 system. This setup will allow writing puppet modules and then you can apply them on your local system and check manually and via serverspec tests that they are doing what you intend them to be doing. Obviously, a VM would be the best test environment for this, or even a container. Let's get started.&lt;/p&gt;
&lt;div class="section" id="setup"&gt;
&lt;h2&gt;Setup&lt;/h2&gt;
&lt;p&gt;Install &lt;tt class="docutils literal"&gt;puppet&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# dnf -y install puppet
&lt;/pre&gt;
&lt;p&gt;Setup the host name:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# cat /etc/hostname
fedora-23.node
&lt;/pre&gt;
&lt;p&gt;Reboot, verify:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# facter | grep node
domain =&amp;gt; node
fqdn =&amp;gt; fedora-23.node
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="our-first-manifest"&gt;
&lt;h2&gt;Our First manifest&lt;/h2&gt;
&lt;p&gt;Let's write our first manifest. We will place it in &lt;tt class="docutils literal"&gt;/etc/puppet/manifests&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Upon installation, &lt;tt class="docutils literal"&gt;/etc/puppet&lt;/tt&gt; looks like:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# tree /etc/puppet/
/etc/puppet/
 ├── auth.conf
 ├── modules
 └── puppet.conf
&lt;/pre&gt;
&lt;p&gt;We will create a &lt;tt class="docutils literal"&gt;manifests&lt;/tt&gt; sub-directory:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# mkdir /etc/puppet/manifests
&lt;/pre&gt;
&lt;p&gt;Now, we will create our first manifest &lt;tt class="docutils literal"&gt;/etc/puppet/manifests/nginx.pp&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
node &amp;quot;fedora-23.node&amp;quot; {
   package { &amp;quot;nginx&amp;quot;:
     ensure =&amp;gt; installed
   }
}
&lt;/pre&gt;
&lt;p&gt;Apply with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--noop&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# puppet apply nginx.pp --noop
Notice: Compiled catalog for fedora-23.node in environment production in 0.66 seconds
Notice: /Stage[main]/Main/Node[fedora-23.node]/Package[nginx]/ensure: current_value purged, should be present (noop)
Notice: Node[fedora-23.node]: Would have triggered 'refresh' from 1 events
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Applied catalog in 0.26 seconds
&lt;/pre&gt;
&lt;p&gt;Really apply:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# puppet apply nginx.pp
Notice: Compiled catalog for fedora-23.node in environment production in 0.60 seconds
Notice: /Stage[main]/Main/Node[fedora-23.node]/Package[nginx]/ensure: created
Notice: Applied catalog in 5.67 seconds
&lt;/pre&gt;
&lt;pre class="code literal-block"&gt;
# rpm -q nginx
nginx-1.8.0-13.fc23.x86_64
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-serverspec-tests"&gt;
&lt;h2&gt;Writing serverspec tests&lt;/h2&gt;
&lt;p&gt;We will first install &lt;tt class="docutils literal"&gt;bundler&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
dnf -y install rubygem-bundler
&lt;/pre&gt;
&lt;p&gt;We will put our serverspec test in &lt;tt class="docutils literal"&gt;/etc/puppet/manifests/tests&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# mkdir /etc/puppet/manifests/tests
# cd /etc/puppet/manifests/tests
&lt;/pre&gt;
&lt;p&gt;Create a &lt;tt class="docutils literal"&gt;Gemfile&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# cat Gemfile
source 'https://rubygems.org'

gem 'serverspec'
gem 'rake'
&lt;/pre&gt;
&lt;p&gt;Install the gems:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# bundle  install --path ./gems/
Installing rake 10.4.2
Installing diff-lcs 1.2.5
Installing multi_json 1.11.2
Installing net-ssh 2.9.2
Installing net-scp 1.2.1
Installing net-telnet 0.1.1
Installing rspec-support 3.3.0
Installing rspec-core 3.3.2
Installing rspec-expectations 3.3.1
Installing rspec-mocks 3.3.2
Installing rspec 3.3.0
Installing rspec-its 1.2.0
Installing sfl 2.2
Installing specinfra 2.43.10
Installing serverspec 2.24.1
Using bundler 1.7.8
Your bundle is complete!
It was installed into ./gems
&lt;/pre&gt;
&lt;p&gt;Initialize the serverspec directory tree:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# bundle exec serverspec-init

Select OS type:

1) UN*X
2) Windows

Select number: 1

Select a backend type:

1) SSH
2) Exec (local)

Select number: 2

+ spec/
+ spec/localhost/
+ spec/localhost/sample_spec.rb
+ spec/spec_helper.rb
+ Rakefile
+ .rspec
&lt;/pre&gt;
&lt;p&gt;Time to write our test in &lt;tt class="docutils literal"&gt;spec/localhost/nginx_spec.rb&lt;/tt&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="code literal-block"&gt;
require 'spec_helper'
describe package('nginx') do
    it { should be_installed }
end
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's run our test:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# bundle exec rake spec
/usr/bin/ruby -I/etc/puppet/manifests/tests/gems/ruby/gems/rspec-core-3.3.2/lib:/etc/puppet/manifests/tests/gems   /ruby/gems/rspec-support-3.3.0/lib /etc/puppet/manifests/tests/gems/ruby/gems/rspec-core-3.3.2/exe/rspec --pattern spec/localhost/\*_spec.rb

Package &amp;quot;nginx&amp;quot;
should be installed

Finished in 0.03447 seconds (files took 0.17465 seconds to load)
1 example, 0 failures
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="our-first-module"&gt;
&lt;h2&gt;Our first module&lt;/h2&gt;
&lt;p&gt;We will now write our first puppet module, we will name it &lt;tt class="docutils literal"&gt;nginx&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# tree modules/nginx/
modules/nginx/
└── manifests
   ├── config
   │&amp;nbsp;&amp;nbsp; ├── config1.pp
   │&amp;nbsp;&amp;nbsp; └── config.pp
   └── init.pp
&lt;/pre&gt;
&lt;p&gt;Create &lt;tt class="docutils literal"&gt;modules/nginx/manifests/init.pp&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# modules/nginx/manifests/init.pp

class nginx {
   package { &amp;quot;nginx&amp;quot;:
      ensure =&amp;gt; installed
   }

   include nginx::config::config
}
&lt;/pre&gt;
&lt;p&gt;Create &lt;tt class="docutils literal"&gt;modules/nginx/manifests/config/config.pp&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# modules/nginx/manifests/config/config.pp
class nginx::config::config{

file { '/etc/nginx/nginx.conf':
    ensure  =&amp;gt; present,
 }
 include nginx::config::config1
}
&lt;/pre&gt;
&lt;p&gt;Create &lt;tt class="docutils literal"&gt;modules/nginx/manifests/config/config1.pp&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# modules/nginx/manifests/config/config1.pp
class nginx::config::config1{
  file { '/etc/nginx/conf.d':
     ensure  =&amp;gt; directory,
  }
}
&lt;/pre&gt;
&lt;p&gt;Let's write a manifest to include this module:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# cat manifests/use-nginx-module.pp
include nginx
&lt;/pre&gt;
&lt;p&gt;Remove &lt;tt class="docutils literal"&gt;nginx&lt;/tt&gt; and appy the manifest above:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
 # dnf remove nginx

 # puppet apply manifests/use-nginx-module.pp --noop
Notice: Compiled catalog for fedora-23.node in environment production in 0.61 seconds
Notice: /Stage[main]/Nginx/Package[nginx]/ensure: current_value purged, should be present (noop)
Notice: Class[Nginx]: Would have triggered 'refresh' from 1 events
Notice: /Stage[main]/Nginx::Config::Config/File[/etc/nginx/nginx.conf]/ensure: current_value absent, should be   present (noop)
Notice: Class[Nginx::Config::Config]: Would have triggered 'refresh' from 1 events
Notice: /Stage[main]/Nginx::Config::Config1/File[/etc/nginx/conf.d]/ensure: current_value absent, should be directory (noop)
Notice: Class[Nginx::Config::Config1]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 3 events
Notice: Applied catalog in 0.24 seconds
&lt;/pre&gt;
&lt;p&gt;And we are done.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="miscellaneous"&gt;
&lt;h2&gt;Miscellaneous&lt;/h2&gt;
&lt;p&gt;Use &lt;tt class="docutils literal"&gt;puppet parser&lt;/tt&gt; to validate your manifest:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ puppet parser validate nginx.pp
&lt;/pre&gt;
&lt;p&gt;Print current module path:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ puppet config print modulepath
/etc/puppet/modules
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="resources"&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.puppetlabs.com/references/latest/type.html#package"&gt;https://docs.puppetlabs.com/references/latest/type.html#package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.digitalocean.com/community/tutorials/how-to-install-puppet-in-standalone-mode-on-centos-7"&gt;https://www.digitalocean.com/community/tutorials/how-to-install-puppet-in-standalone-mode-on-centos-7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://serverspec.org/tutorial.html"&gt;http://serverspec.org/tutorial.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.debian-administration.org/article/703/A_brief_introduction_to_server-testing_with_serverspec"&gt;https://www.debian-administration.org/article/703/A_brief_introduction_to_server-testing_with_serverspec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Advanced serverspec tips: &lt;a class="reference external" href="http://serverspec.org/advanced_tips.html"&gt;http://serverspec.org/advanced_tips.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary></entry><entry><title>Fedora 22 Scientific</title><link href="/fedora-22-scientific.html" rel="alternate"></link><published>2015-06-11T10:20:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-06-11:fedora-22-scientific.html</id><summary type="html">&lt;p&gt;Fedora 22 was &lt;a class="reference external" href="http://fedoramagazine.org/fedora-22-released/"&gt;released recently&lt;/a&gt; which also means we
have a new Fedora Scientific release. &lt;a class="reference external" href="https://labs.fedoraproject.org/en/scientific/"&gt;Fedora Scientific&lt;/a&gt;
is now part of &lt;a class="reference external" href="http://fedoramagazine.org/new-websites-fedora-22/"&gt;Fedora labs&lt;/a&gt;.&lt;/p&gt;
&lt;a class="reference external image-reference" href="https://labs.fedoraproject.org/en/scientific/"&gt;&lt;img alt="Featured Applications Image" class="align-center" src="/images/scientific-featured-applications.png" style="width: 650.0px; height: 550.0px;" /&gt;&lt;/a&gt;
&lt;p&gt;As you can see, the new home for Fedora Scientific looks
amazing. The &amp;quot;Featured Applications&amp;quot; section features the most
important and useful tools in Fedora Scientific. I think that is a
great idea. Everyone associated with it, thank you very much.&lt;/p&gt;
&lt;p&gt;I have also updated the &lt;a class="reference external" href="http://fedora-scientific.readthedocs.org/"&gt;Fedora Scientific Guide&lt;/a&gt; to reflect the
changes.&lt;/p&gt;
</summary></entry><entry><title>Remapping http://echorand.me</title><link href="/remapping-httpechorandme.html" rel="alternate"></link><published>2015-04-30T10:20:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-04-30:remapping-httpechorandme.html</id><summary type="html">&lt;p&gt;I changed the mapping of my domain to point to my GitHub pages. My old
blog content is still available &lt;a class="reference external" href="http://amitksaha.wordpress.com"&gt;here&lt;/a&gt;.&lt;/p&gt;
</summary></entry></feed>