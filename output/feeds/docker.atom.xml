<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Exploring Software and Writing about it - Docker</title><link href="http://echorand.me/" rel="alternate"></link><link href="http://echorand.me/feeds/docker.atom.xml" rel="self"></link><id>http://echorand.me/</id><updated>2017-10-29T22:00:00+10:00</updated><entry><title>Add an additional host entry to docker container</title><link href="http://echorand.me/add-an-additional-host-entry-to-docker-container.html" rel="alternate"></link><published>2017-10-29T22:00:00+10:00</published><updated>2017-10-29T22:00:00+10:00</updated><author><name>Amit Saha</name></author><id>tag:echorand.me,2017-10-29:/add-an-additional-host-entry-to-docker-container.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let's say a program in a container should be able to resolve a custom hostname.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When using &lt;code&gt;docker run&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker run --add-host myhost.name:127.0.0.1 -ti python bash
Unable to find image &lt;span class="s1"&gt;&amp;#39;python:latest&amp;#39;&lt;/span&gt; locally
latest: Pulling from library/python
Digest: sha256:eb20fd0c13d2c57fb602572f27f05f7f1e87f606045175c108a7da1af967313e
Status …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let's say a program in a container should be able to resolve a custom hostname.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When using &lt;code&gt;docker run&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker run --add-host myhost.name:127.0.0.1 -ti python bash
Unable to find image &lt;span class="s1"&gt;&amp;#39;python:latest&amp;#39;&lt;/span&gt; locally
latest: Pulling from library/python
Digest: sha256:eb20fd0c13d2c57fb602572f27f05f7f1e87f606045175c108a7da1af967313e
Status: Downloaded newer image &lt;span class="k"&gt;for&lt;/span&gt; python:latest
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will show up as an additional entry in the container's &lt;code&gt;/etc/hosts&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@fee9aeccbc4b:/# cat /etc/hosts
...
127.0.0.1   myhost.name
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With &lt;code&gt;docker compose&lt;/code&gt;, we can use the &lt;code&gt;extra_hosts&lt;/code&gt; key:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;extra_hosts:
    - &amp;quot;myhost.name:127.0.0.1&amp;quot;
&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>User-defined networks in Docker for inter-container communication</title><link href="http://echorand.me/user-defined-networks-in-docker-for-inter-container-communication.html" rel="alternate"></link><published>2017-10-26T15:00:00+10:00</published><updated>2017-10-26T15:00:00+10:00</updated><author><name>Amit Saha</name></author><id>tag:echorand.me,2017-10-26:/user-defined-networks-in-docker-for-inter-container-communication.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let's say a program in a container wants to communicate with a service running in another docker container
on the same host. The current recommended approach to do so is using a &lt;code&gt;user-defined&lt;/code&gt; network and 
&lt;a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/"&gt;avoid&lt;/a&gt; using &lt;code&gt;links&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Docker user defined network" src="http://echorand.me/images/docker-user-defined-network.png" title="Docker user defined network"&gt;&lt;/p&gt;
&lt;p&gt;Create an &lt;a href="https://docs.docker.com/engine/userguide/networking/#user-defined-networks"&gt;user-defined network&lt;/a&gt;
and run both (or as many …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let's say a program in a container wants to communicate with a service running in another docker container
on the same host. The current recommended approach to do so is using a &lt;code&gt;user-defined&lt;/code&gt; network and 
&lt;a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/"&gt;avoid&lt;/a&gt; using &lt;code&gt;links&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Docker user defined network" src="http://echorand.me/images/docker-user-defined-network.png" title="Docker user defined network"&gt;&lt;/p&gt;
&lt;p&gt;Create an &lt;a href="https://docs.docker.com/engine/userguide/networking/#user-defined-networks"&gt;user-defined network&lt;/a&gt;
and run both (or as many you have) the containers in this network:
(For reference, I am using docker 17.09.0-ce)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker network create --driver bridge webapp1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first container which we will launch in this network is a HTTP server listening 
on port 8000. The &lt;code&gt;Dockerfile&lt;/code&gt; is as follows:&lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/bd31ad432f83bfd178f0cedd7a45d59f.js?file=webapp.Dockerfile'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;# Build me using: docker build -t amitsaha/webapp .
FROM python:3
CMD ["python3", "-m", "http.server"]&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;p&gt;Start the container in the network we created above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker run -d -network webapp1 -name webapp amitsaha/webapp
94a3f4631eb924f7e4339986b73b1af7fca4c09b2a1a8d3ea106b698eae5c577
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, we will communicate with the web application from another container:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker run -network webapp1 -rm appropriate/curl -fsSL webapp:8000
&amp;lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML &lt;span class="m"&gt;4&lt;/span&gt;.01//EN” “http://www.w3.org/TR/html4/strict.dtd&lt;span class="s2"&gt;&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we tried to communicate with webapp container from a container on a different network, 
we will get a name resolution error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker run --rm appropriate/curl -fsSL webapp:8000
curl: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; Couldn&lt;span class="s1"&gt;&amp;#39;t resolve host &amp;#39;&lt;/span&gt;webapp&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Background information&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When we install docker, by default, we have three networks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
8a6a3da7b5a2        bridge              bridge              &lt;span class="nb"&gt;local&lt;/span&gt;
31f4f28111f0        host                host                &lt;span class="nb"&gt;local&lt;/span&gt;
b0dfa09e8949        none                null                &lt;span class="nb"&gt;local&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When we run a container (like so, &lt;code&gt;docker run -ti &amp;lt;image&amp;gt;&lt;/code&gt;), it will use the default &lt;code&gt;bridge&lt;/code&gt; network. 
In this network mode, your container can access the outside world and the outside world can communicate 
with your container via published service ports. In this mode, however there is no "automagic" way for 
another container using the bridge network to communicate with it. The &lt;code&gt;host&lt;/code&gt; network runs a container in 
the host’s network space. The &lt;code&gt;none&lt;/code&gt; network essentially gives our container only the loopback interface.&lt;/p&gt;
&lt;p&gt;When we create a user-defined network, we are creating an isolated network for our containers where we 
&lt;a href="https://docs.docker.com/engine/userguide/networking/configure-dns/"&gt;automatically&lt;/a&gt;
get container name resolution to facilitate inter-container communication. In addition, 
we can expose and publish ports for a service to be also accessible from outside the container.
If you look at the output of &lt;code&gt;docker network ls&lt;/code&gt; again, you will see an additional entry 
for the network we created:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
e865bd63c762        webapp1             bridge              &lt;span class="nb"&gt;local&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Learn &lt;a href="https://docs.docker.com/engine/userguide/networking/"&gt;more&lt;/a&gt; about docker container networking.&lt;/li&gt;
&lt;li&gt;To learn even more, I recommend &lt;a href="http://blog.mbrt.it/2017-10-01-demystifying-container-networking/?utm_source=webopsweekly&amp;amp;utm_medium=email"&gt;Demystifying container networkking&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Data only Docker containers</title><link href="http://echorand.me/data-only-docker-containers.html" rel="alternate"></link><published>2015-12-13T11:00:00+10:00</published><updated>2015-12-13T11:00:00+10:00</updated><author><name>Amit Saha</name></author><id>tag:echorand.me,2015-12-13:/data-only-docker-containers.html</id><summary type="html">&lt;p&gt;In this post, we shall take a look at the idea of data only
containers - containers whose sole purpose is to exist on the &lt;em&gt;docker
host&lt;/em&gt; so that other containers can have portable access to a
persistent data volume.&lt;/p&gt;
&lt;div class="section" id="why-do-we-need-a-persistent-data-volume"&gt;
&lt;h2&gt;Why do we need a persistent data volume?&lt;/h2&gt;
&lt;p&gt;We will experiment …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;In this post, we shall take a look at the idea of data only
containers - containers whose sole purpose is to exist on the &lt;em&gt;docker
host&lt;/em&gt; so that other containers can have portable access to a
persistent data volume.&lt;/p&gt;
&lt;div class="section" id="why-do-we-need-a-persistent-data-volume"&gt;
&lt;h2&gt;Why do we need a persistent data volume?&lt;/h2&gt;
&lt;p&gt;We will experiment with the &lt;tt class="docutils literal"&gt;jenkins&lt;/tt&gt; image from the &lt;a class="reference external" href="https://hub.docker.com/_/jenkins/"&gt;docker
hub&lt;/a&gt;. Let's run a jenkins
container using &lt;cite&gt;$ sudo docker run -p 8080:8080 jenkins&lt;/cite&gt;. Now, if we
visit the URL &lt;cite&gt;http://docker-host-ip:8080&lt;/cite&gt;, we will see the familiar
Jenkins home page.&lt;/p&gt;
&lt;p&gt;By default, a Jenkins installation doesn't come with any
authentication configured. Hence, we will first setup a simple
authentication setup using Jenkins' own user password database. To do
so, we will visit the URL:
&lt;cite&gt;http://docker-host-ip:8080/configureSecurity/&lt;/cite&gt; and check the &lt;tt class="docutils literal"&gt;Enable
security&lt;/tt&gt; checkbox and then select the &lt;tt class="docutils literal"&gt;Jenkins&lt;/tt&gt; own user database`
option, and check the &lt;tt class="docutils literal"&gt;Allow users to sign up&lt;/tt&gt; check box under
&lt;tt class="docutils literal"&gt;Security Realm&lt;/tt&gt;, select the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Logged-in&lt;/span&gt; users can do anything&lt;/tt&gt;
option and finally click on &lt;tt class="docutils literal"&gt;Save&lt;/tt&gt;. This will bring us to the login
page from where we can create a new account since we don't have one
yet. Now, we will exit out of the container - we can use &lt;tt class="docutils literal"&gt;Ctrl + c&lt;/tt&gt;
combination for that. Now, if we restart the container using the
previous command, you will see that none of the configuration changes
above has been saved.&lt;/p&gt;
&lt;p&gt;The reason for that is because none of the changes we make during a
container's lifetime in it's own file system is preserved. So, we need
&lt;em&gt;data volumes&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="persistent-data-with-a-volume-mount"&gt;
&lt;h2&gt;Persistent data with a volume mount&lt;/h2&gt;
&lt;p&gt;If you look at the
&lt;a class="reference external" href="https://github.com/jenkinsci/docker/blob/master/Dockerfile"&gt;Dockerfile&lt;/a&gt;
you will see the command &lt;tt class="docutils literal"&gt;VOLUME /var/jenkins_home&lt;/tt&gt;. This
essentially means that the mount point &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt; points to
a location on the docker host. Hence, the changes made in that
directory will be available from the host even after you have exited
the container. However, the catch here is that every time you run a
new container, the host location it mounts to will change and hence as
we saw above, the data we wrote (via the configuration changes) were
not visible the next time we started a container from the same
image. To achieve that, we have to do things slightly differently. We
will start the container and give a name to it:&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;`
$ sudo docker run &lt;span class="pre"&gt;-p&lt;/span&gt; 8080:8080 &lt;span class="pre"&gt;--name&lt;/span&gt; jenkins jenkins
`&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;We will perform the same configuration changes above and exit the
container using Ctrl + C. Next, we will &lt;tt class="docutils literal"&gt;start&lt;/tt&gt; the container using
&lt;tt class="docutils literal"&gt;sudo docker start jenkins&lt;/tt&gt;. You will see all your changes have been
preserved.&lt;/p&gt;
&lt;p&gt;So, now we have a setup of jenkins where our changes are preserved, so
long as we make sure we start/stop the containers and not run a new
container from the &lt;tt class="docutils literal"&gt;jenkins&lt;/tt&gt; image. The key point to take away from
here is that for a specific container, the host directory the volume
maps to is always the same. This leads to the use of what is commonly
referred to as &lt;tt class="docutils literal"&gt;data containers&lt;/tt&gt; for persistent data storage in
containers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-data-containers-for-persistent-storage"&gt;
&lt;h2&gt;Using data containers for persistent storage&lt;/h2&gt;
&lt;p&gt;The idea here is that you use the same base image from which your
actual container will run to only create a container (using &lt;tt class="docutils literal"&gt;docker
create&lt;/tt&gt;), not run it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ sudo docker create --name jenkins-data jenkins
&lt;/pre&gt;
&lt;p&gt;We gave the name &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jenkins-data&lt;/span&gt;&lt;/tt&gt; to this container and it's only
purpose is to be there on our filesystem to serve as a source of
persistent &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt; for other jenkins containers. Let's
run a jenkins container now:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ sudo docker run --volumes-from jenkins-data -p 8080:8080 jenkins
&lt;/pre&gt;
&lt;p&gt;As earlier, we can now go to the Jenkins home page at
&lt;cite&gt;http://docker-host-ip:8080/configureSecurity/&lt;/cite&gt; and make the above
configuration changes. You can now exit the container and use the
above command to run another jenkins container. The changes will still
be visible. We are no more restricted to starting and stopping the
same container since our &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;jenkins-data&lt;/span&gt;&lt;/tt&gt; container will have all our
changes stored in its &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt;. You can have other
containers (perhaps a container for
&lt;a class="reference external" href="https://github.com/discordianfish/docker-lloyd"&gt;backing up&lt;/a&gt; your
&lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt;) being able to access the same data by using the
same &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;volumes-from&lt;/span&gt;&lt;/tt&gt; option.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="comparison-to-volume-mounting-a-host-directory"&gt;
&lt;h2&gt;Comparison to volume mounting a host directory&lt;/h2&gt;
&lt;p&gt;The alternative to using data containers is to mount a directory from
the host as &lt;tt class="docutils literal"&gt;/var/jenkins_home&lt;/tt&gt; in the container. This approach will
solve our end-goal, but there are two additional steps that one would
need to do:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Decide which host location to use, perhaps creating it&lt;/li&gt;
&lt;li&gt;Making sure the container will have appropriate read-write permissions (including &lt;a class="reference external" href="www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/"&gt;SELinux
labels&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We don't need to do either of these when using data containers. As
long as the image we plan to use has the appropriate &lt;tt class="docutils literal"&gt;VOLUME&lt;/tt&gt;
command in it's Dockerfile, we can adopt the same approach we did
here to make sure the data we care about is persisted. For images,
which don't, we can easily enough create our own image and add the
appropriate &lt;tt class="docutils literal"&gt;VOLUME&lt;/tt&gt; commands. And hence, this is a &lt;strong&gt;portable&lt;/strong&gt;
approach to data persistence - it is not reliant on the host
setup.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, these are the main reasons why data containers are a
good approach to have persistent storage for your containers:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;No requirement to setup host&lt;/li&gt;
&lt;li&gt;The permissions are automatically taken care of since we are using the same base image&lt;/li&gt;
&lt;li&gt;Multiple containers can easily have access to the same data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following links may be helpful to learn more:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.docker.com/userguide/dockervolumes/"&gt;Managing data in Containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://medium.com/&amp;#64;ramangupta/why-docker-data-containers-are-good-589b3c6c749e"&gt;Why Docker Data Containers are Good&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content></entry><entry><title>Mounting a docker volume on SELinux enabled host</title><link href="http://echorand.me/mounting-a-docker-volume-on-selinux-enabled-host.html" rel="alternate"></link><published>2015-10-05T11:00:00+10:00</published><updated>2015-10-05T11:00:00+10:00</updated><author><name>Amit Saha</name></author><id>tag:echorand.me,2015-10-05:/mounting-a-docker-volume-on-selinux-enabled-host.html</id><summary type="html">&lt;p&gt;My workflow with docker usually involves volume mounting a host
directory so that I can read and write to the host directory from my
container as a &lt;em&gt;non-root&lt;/em&gt; user. On a Fedora 23 host with SELinux
enabled, this is what I have to do differently:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Use: -v /var/dir1:var …&lt;/pre&gt;</summary><content type="html">&lt;p&gt;My workflow with docker usually involves volume mounting a host
directory so that I can read and write to the host directory from my
container as a &lt;em&gt;non-root&lt;/em&gt; user. On a Fedora 23 host with SELinux
enabled, this is what I have to do differently:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Use: -v /var/dir1:var/dir1:Z
&lt;/pre&gt;
&lt;p&gt;Note the extra Z above? You can learn more about it this
&lt;a class="reference external" href="http://www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/"&gt;Project Atomic blog post&lt;/a&gt;&lt;/p&gt;
</content></entry></feed>