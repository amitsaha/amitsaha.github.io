<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Programming and Writing about it</title><link href="/" rel="alternate"></link><link href="/feeds/python.atom.xml" rel="self"></link><id>/</id><updated>2015-11-30T12:00:00+10:00</updated><entry><title>A virtualenv first approach to Python projects</title><link href="/a-virtualenv-first-approach-to-python-projects.html" rel="alternate"></link><published>2015-11-30T12:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-11-30:a-virtualenv-first-approach-to-python-projects.html</id><summary type="html">&lt;p&gt;I have until the last few months (of my ~4 years of working with
Python) always worked without virtualenv for all my Python
projects. Why? I think I found the whole idea of having to do the
following two steps before I work on something cumbersome:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Remember the exact virtualenv name, and then&lt;/li&gt;
&lt;li&gt;Activate it&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That said, I was very much aware that it was certainly a good thing
to do and would cause me less headaches someday. That someday finally
came, and I ran into conflicting package requirements for applications
which needed to run simultaneously. This forced me to start using
virtualenvs. I think I also found the tool which will make me  keep
using them even when I don't &lt;em&gt;need&lt;/em&gt; to. The tool is &lt;a class="reference external" href="https://github.com/berdario/pew"&gt;pew&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="installation-and-basics"&gt;
&lt;h2&gt;Installation and Basics&lt;/h2&gt;
&lt;p&gt;The home page lists various options of installing &lt;tt class="docutils literal"&gt;pew&lt;/tt&gt;. The most
straightforward is of course to just use &lt;tt class="docutils literal"&gt;pip install pew&lt;/tt&gt;. Once you
have it installed, typing &lt;tt class="docutils literal"&gt;pew&lt;/tt&gt; lists the various sub-commands, such
as &lt;tt class="docutils literal"&gt;new&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;workon&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;ls&lt;/tt&gt; and others. Eac of the sub-commands is
accompanied by a summary of they will do.&lt;/p&gt;
&lt;p&gt;So far, I have been mostly working with the above sub-commands. Here
is how we can create a new virtualenv:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ pew new flask-graphql-demo
New python executable in flask-graphql-demo/bin/python2
Also creating executable in flask-graphql-demo/bin/python
Installing setuptools, pip...done.
Launching subshell in virtual environment. Type 'exit' or 'Ctrl+D' to return.
flask-graphql-demo $
&lt;/pre&gt;
&lt;p&gt;Our virtualenv &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;flask-graphql-demo&lt;/span&gt;&lt;/tt&gt; is created and we are in it, which we can check:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ which pip
~/.local/share/virtualenvs/flask-graphql-demo/bin/pip
&lt;/pre&gt;
&lt;p&gt;We can do all our usual work now (installing other packages, running
our applications) and once done, we can simply &lt;tt class="docutils literal"&gt;exit&lt;/tt&gt; and we will be
out of the virtualenv.&lt;/p&gt;
&lt;p&gt;Now, if I want to resume work on this particular project, I can first
use &lt;tt class="docutils literal"&gt;pew ls&lt;/tt&gt; to list the currently created virtualenvs:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
$ pew ls
flask-graphql-demo
&lt;/pre&gt;
&lt;p&gt;and then use &lt;tt class="docutils literal"&gt;pew workon &lt;span class="pre"&gt;flask-graphql-demo&lt;/span&gt;&lt;/tt&gt; to start working on it
again. On Linux, &lt;tt class="docutils literal"&gt;pew workon&lt;/tt&gt; also gives me all the available
virtualenvs as suggestions automatically.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;As you may have already seen, &lt;tt class="docutils literal"&gt;pew&lt;/tt&gt; has a number of other features
which should make working with &lt;tt class="docutils literal"&gt;virtualenvs&lt;/tt&gt; really easy. It has
definitely made me change my approach to working on Python projects.&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><title>PYTHONHASHSEED and your tests</title><link href="/pythonhashseed-and-your-tests.html" rel="alternate"></link><published>2015-11-19T11:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-11-19:pythonhashseed-and-your-tests.html</id><summary type="html">&lt;p&gt;Recently at work, I wanted to test a string which was being created by the &lt;tt class="docutils literal"&gt;urllib.urlencode()&lt;/tt&gt; function. My first attempt was simple - test my expected string with that being created by the function above using unittest's &lt;tt class="docutils literal"&gt;assertEquals()&lt;/tt&gt; function. It passed all the times I ran the tests before I committed the code, but it started failing when the tests were ran as part of the deployment process.&lt;/p&gt;
&lt;p&gt;The input to the &lt;tt class="docutils literal"&gt;urllib.urlencode()&lt;/tt&gt; function is a dictionary of key value pairs and hence the returned value can really be any of the arrangements of the key value pairs. So, for example &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;{'key1':'value',&lt;/span&gt; &lt;span class="pre"&gt;'key2':'value'}&lt;/span&gt;&lt;/tt&gt; can result in the query string &lt;tt class="docutils literal"&gt;key1=value&amp;amp;key2=value&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;key2=value&amp;amp;key1=value&lt;/tt&gt;. We cannot know for sure and we shouldn't need to.&lt;/p&gt;
&lt;p&gt;Thus, we cannot use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;self.assertEquals(urllib.urlencode({'key1':'value',&lt;/span&gt; &lt;span class="pre"&gt;{'key2':'value'}),&lt;/span&gt; 'key1=value&amp;amp;key2=value')&lt;/tt&gt; without the possibility that it will fail eventually. The reason why we see such behaviour of course is that for dictionaries, the order in which the keys are stored is not deterministic - or known apriori. You can see this behaviour by explicitly setting the value of &lt;a class="reference external" href="https://docs.python.org/3.3/using/cmdline.html#envvar-PYTHONHASHSEED"&gt;PYTHONHASHSEED&lt;/a&gt; to different values.&lt;/p&gt;
&lt;p&gt;So, how should we write such tests? Let's see one possible way which I will state as - &lt;strong&gt;Instead of asserting the equality of entire objects, we should be testing for the presence of the expected constituent objects&lt;/strong&gt;. I demonstrate it via two similar examples:&lt;/p&gt;
&lt;p&gt;(Note that I have used the builtin &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; statement to test here)&lt;/p&gt;
&lt;div class="section" id="url-encoding-via-urllib-urlencode"&gt;
&lt;h2&gt;URL encoding via urllib.urlencode()&lt;/h2&gt;
&lt;p&gt;As our first example, let's consider the &lt;tt class="docutils literal"&gt;urllib.urlencode()&lt;/tt&gt; function:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
 # Test for the role of PYTHONHASHSEED - urllib urlencode

import urllib
urlencode_input = {'param1': 'value', 'param2': 'value'}
expected_query_string = 'param1=value&amp;amp;param2=value'

# This will fail for *some* PYTHONHASHSEED
def test_urlencode_1():
    assert urllib.urlencode(urlencode_input) == expected_query_string

# This will not fail for *any* PYTHONHASHSEED
def test_urlencode_2():
    query_string = urllib.urlencode(urlencode_input)
    assert 'param1=value' in query_string
    assert 'param2=value' in query_string
&lt;/pre&gt;
&lt;p&gt;Run the above tests a few times each starting with a different value of &lt;tt class="docutils literal"&gt;PYTHONHASHEED&lt;/tt&gt; (for. e.g on Linux/Mac OS X, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHONHASHSEED=&amp;lt;some&lt;/span&gt; integer&amp;gt; nosetests&lt;/tt&gt;) and you will be easily able to see that the first test will fail for some value, but the second test will always pass.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="joining-strings-from-dictionaries"&gt;
&lt;h2&gt;Joining strings from dictionaries&lt;/h2&gt;
&lt;p&gt;This is similar to the previous example. Assume a function below which basically concatenates multiple key value pairs to create the conditional part of a SQL &lt;tt class="docutils literal"&gt;WHERE&lt;/tt&gt; clause:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
def create_where_clause(conditions):
    where_clause = ''
    for k, v in conditions.iteritems():
        where_clause += '%s=%s AND ' % (k, v)
    # remove the last AND and a trailing space
    return where_clause[:-5]
&lt;/pre&gt;
&lt;p&gt;Here are two ways of testing this function - the first will fail for some test run, where as the second will not:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
# This will fail for *some* PYTHONHASHSEED
def test_where_clause_1():

    where_clause = create_where_clause({'item1': 1, 'item2': 2})
    expected_where_clause = 'item1=1 AND item2=2'
    assert where_clause==expected_where_clause

# This will not fail for *any* PYTHONHASHSEED
def test_where_clause_2():

    where_clause = create_where_clause({'item1': 1, 'item2': 2})

    # Deconstruct the string returned into individual conditions
    conditions = [cond.strip() for cond in where_clause.split('AND')]
    assert 'item1=1' in conditions
    assert 'item2=2' in conditions
&lt;/pre&gt;
&lt;p&gt;If you run the above tests with different &lt;tt class="docutils literal"&gt;PYTHONHASHSEED&lt;/tt&gt; values, you will notice similar behaviour to the previous example.&lt;/p&gt;
&lt;p&gt;If you are using &lt;a class="reference external" href="https://testrun.org/tox/latest/example/basic.html#special-handling-of-pythonhashseed"&gt;tox&lt;/a&gt; to run your tests, it automatically sets &lt;tt class="docutils literal"&gt;PYTHONHASHSEED&lt;/tt&gt; to a random integer when it is invoked. Hence, if you have never had your tests fail so far, there is a good chance your tests do not make any assumptions of order when dealing with Python dictionaries - but that of course is no guarantee that your tests are completely free since there may be this particular random number that has not been tried yet! So, ideally you may just want to do run your tests (especially if they don't take long) for a large number of PYTHONHASHSEED values just to be more confident.&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><title>Mock objects and non-existent attributes/methods in Python</title><link href="/mock-objects-and-non-existent-attributesmethods-in-python.html" rel="alternate"></link><published>2015-01-11T14:00:00+10:00</published><author><name>Amit Saha</name></author><id>tag:,2015-01-11:mock-objects-and-non-existent-attributesmethods-in-python.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Updated&lt;/em&gt;: Fixed typo in the last paragraph.&lt;/p&gt;
&lt;p&gt;Today, I was curious to see this behavior of &lt;tt class="docutils literal"&gt;Mock()&lt;/tt&gt; objects when using &lt;a class="reference external" href="https://github.com/testing-cabal/mock"&gt;mock&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from mock import Mock
&amp;gt;&amp;gt;&amp;gt; m = Mock()
&amp;gt;&amp;gt;&amp;gt; m.i_dont_exist
&amp;lt;Mock name='mock.i_dont_exist' id='139841609578768'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; m.i_dont_exist()
&amp;lt;Mock name='mock.i_dont_exist()' id='139841609106896'&amp;gt;
&lt;/pre&gt;
&lt;p&gt;The above is expected, since I have not declared a spec when creating the &lt;tt class="docutils literal"&gt;Mock()&lt;/tt&gt; object, so even when you call a non-existent method or get/set a non-existent attribute, you will not get a &lt;tt class="docutils literal"&gt;AttributeError&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;However, I was suprised by the following:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; m.assert_not_calledd
Traceback (most recent call last):
 File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
File &amp;quot;/home/asaha/.local/share/virtualenvs/606fc8723c1a01b/lib/python2.7/site-packages/mock/mock.py&amp;quot;, line 721, in _    _getattr__
   raise AttributeError(name)
 AttributeError: assert_not_calledd
&lt;/pre&gt;
&lt;p&gt;And the following as well:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; m.assert_foo
Traceback (most recent call last):
File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
File &amp;quot;/home/asaha/.local/share/virtualenvs/606fc8723c1a01b/lib/python2.7/site-packages/mock/mock.py&amp;quot;, line 721, in __getattr__
  raise AttributeError(name)
  AttributeError: assert_foo
&lt;/pre&gt;
&lt;p&gt;I guessed that there is likely a check explicitly for &lt;strong&gt;non-existent
attributes&lt;/strong&gt; starting with &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt;, and if it finds so, it will
raise a &lt;tt class="docutils literal"&gt;AttributeError&lt;/tt&gt;.  If you look at the &lt;a class="reference external" href="https://github.com/testing-cabal/mock/blob/master/mock/mock.py#L708"&gt;__getattr__&lt;/a&gt;
method in &lt;tt class="docutils literal"&gt;mock.py&lt;/tt&gt;, you will see that this is pretty much what is
happening. The exact lines are below:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
if not self._mock_unsafe: # self._mock_unsafe is by default False
    if name.startswith(('assert', 'assret')): # It comes here and an AttributeError is raised
        raise AttributeError(name)
&lt;/pre&gt;
&lt;p&gt;This is certainly a good thing, since I have often seen
&lt;a class="reference external" href="http://engineeringblog.yelp.com/2015/02/assert_called_once-threat-or-menace.html"&gt;assert_called_once&lt;/a&gt;
in codebases, and is fairly easy to overlook.&lt;/p&gt;
</summary></entry></feed>